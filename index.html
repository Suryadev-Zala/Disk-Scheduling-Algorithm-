<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disk Scheduling Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        /* Base Styles (Condensed) */
        @font-face {
            font-family: 'LucideIcons';
            src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
        }

        .lucide {
            font-family: 'LucideIcons';
            font-size: 1.1rem;
            line-height: 1;
            display: inline-block;
            vertical-align: middle;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #334155;
        }

        .section-card {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            margin-bottom: 2rem;
        }

        .visualization-box {
            border: 1px solid #e2e8f0;
            background-color: #f8fafc;
            border-radius: 0.375rem;
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .trace-canvas {
            display: block;
            width: 100%;
            height: 450px;
            border: 1px solid #e2e8f0;
            border-radius: 0.25rem;
        }

        #comparison-graph-canvas {
            display: block;
            width: 100%;
            height: 400px;
            border: 1px solid #e2e8f0;
            border-radius: 0.25rem;
            background-color: #f8fafc;
        }

        #all-in-one-canvas {
            display: block;
            width: 100%;
            height: 600px;
            border-radius: 0.25rem;
            border: 1px solid #475569;
        }

        #queue-plot-canvas {
            display: block;
            width: 100%;
            height: 350px;
            border: 1px solid #e2e8f0;
            border-radius: 0.25rem;
            background-color: #f8fafc;
        }

        .all-in-one-container,
        .comparison-container,
        .canvas-container,
        .queue-plot-container {
            position: relative;
            width: 100%;
            margin-left: auto;
            margin-right: auto;
        }

        .all-in-one-container {
            max-width: 1000px;
            margin-top: 1rem;
        }

        .comparison-container {
            max-width: 900px;
            margin-top: 2rem;
        }

        .canvas-container {
            max-width: 800px;
            padding-bottom: 25px;
        }

        .queue-plot-container {
            max-width: 800px;
            padding-bottom: 25px;
            margin-top: 1rem;
        }

        .axis-label {
            font-size: 0.75rem;
            color: #475569;
            white-space: nowrap;
            position: absolute;
        }

        .all-in-one-container .x-axis-label {
            color: #cbd5e1;
            bottom: auto;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 500;
        }

        .all-in-one-container .y-axis-label {
            color: #cbd5e1;
            left: 15px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left center;
            font-weight: 500;
        }

        .canvas-container .y-axis-label {
            top: 50%;
            left: 10px;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left center;
        }

        .canvas-container .x-axis-label {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .queue-plot-container .y-axis-label {
            top: 50%;
            left: 10px;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left center;
        }

        .queue-plot-container .x-axis-label {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .trace-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2.5rem;
            width: 100%;
        }

        .trace-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .trace-item h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.2rem;
            text-align: center;
        }

        .trace-item .movement-info {
            font-size: 0.875rem;
            color: #475569;
            margin-bottom: 0.5rem;
            font-family: 'Roboto Mono', monospace;
            text-align: center;
        }

        .trace-item .movement-info strong {
            color: #4f46e5;
            font-weight: 600;
        }

        .live-movement-display {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: -0.3rem;
            margin-bottom: 0.5rem;
            font-family: 'Roboto Mono', monospace;
            height: 1.2em;
            /* Reserve space */
        }

        input[type="number"],
        input[type="text"],
        select {
            border-color: #cbd5e1;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            border-width: 1px;
            width: 100%;
        }

        input:disabled,
        select:disabled,
        input[type="text"]:read-only {
            background-color: #f1f5f9;
            cursor: not-allowed;
            opacity: 0.7;
        }

        input[type="number"]:focus,
        input[type="text"]:focus:not(:read-only),
        select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px #c7d2fe;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            cursor: pointer;
            border: 1px solid transparent;
            white-space: nowrap;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #4338ca;
        }

        .btn-secondary {
            background-color: #e2e8f0;
            color: #1e293b;
            border-color: #cbd5e1;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #cbd5e1;
        }

        .btn-indigo {
            background-color: #6366f1;
            color: white;
        }

        .btn-indigo:hover:not(:disabled) {
            background-color: #4f46e5;
        }

        .btn-teal {
            background-color: #14b8a6;
            color: white;
        }

        .btn-teal:hover:not(:disabled) {
            background-color: #0d9488;
        }

        .btn-green {
            background-color: #22c55e;
            color: white;
        }

        .btn-green:hover:not(:disabled) {
            background-color: #16a34a;
        }

        .btn-lg {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
        }

        .metric-button {
            padding: 0.5rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.375rem;
            background-color: white;
            color: #334155;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            font-size: 0.875rem;
        }

        .metric-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #f8fafc;
        }

        .metric-button.active {
            background-color: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .metric-button:hover:not(.active):not(:disabled) {
            background-color: #f1f5f9;
        }

        .sort-button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .sort-button.active {
            background-color: #a5b4fc;
            border-color: #818cf8;
            color: #3730a3;
        }

        h1,
        h2 {
            color: #1e293b;
        }

        label {
            color: #334155;
            font-weight: 500;
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
        }

        p {
            color: #475569;
            line-height: 1.6;
        }

        .comparison-table {
            width: 100%;
            margin-top: 1.5rem;
            border-collapse: collapse;
            font-size: 0.875rem;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            border-radius: 0.375rem;
            overflow: hidden;
        }

        .comparison-table th,
        .comparison-table td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem 1rem;
            text-align: left;
        }

        .comparison-table th {
            background-color: #f1f5f9;
            font-weight: 600;
            color: #334155;
        }

        .comparison-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }

        .comparison-table tbody tr:hover {
            background-color: #f1f5f9;
        }

        .comparison-table td:not(:first-child) {
            text-align: right;
            font-family: 'Roboto Mono', monospace;
        }

        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem 1.5rem;
            margin-top: 1rem;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: #475569;
        }

        .legend-color-box {
            width: 12px;
            height: 12px;
            border: 1px solid #94a3b8;
            display: inline-block;
            border-radius: 2px;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 9px;
            white-space: nowrap;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }



        .rank-text {
            font-size: 0.9em;
            color: #64748b;
            /* slate-500 */
        }

        .algo-selection-container {
            margin-top: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #f1f5f9;
            border-radius: 0.375rem;
        }

        .algo-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.75rem;
        }

        .algo-checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: background-color 0.1s ease;
        }

        .algo-checkbox-label:hover {
            background-color: #e2e8f0;
        }

        .algo-checkbox-label input[type="checkbox"] {
            cursor: pointer;
            accent-color: #4f46e5;
        }



        .best-algo-text {
            font-weight: 700;
            color: #16a34a;
            /* green-600 */
        }

        .comparison-table .best-algo-row td {
            background-color: #dcfce7 !important;
            /* light green bg */
            font-weight: 600;
        }

        .comparison-table .best-algo-row td:first-child {
            color: #15803d;
        }

        .queue-input-mode-container {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .queue-gen-controls {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            align-items: end;
        }

        .queue-gen-controls .flex-col {
            min-width: 150px;
            /* Ensure controls don't get too squished */
        }

        .queue-plot-point {
            fill: #3b82f6;
            /* blue-500 */
            opacity: 0.7;
        }
    </style>
</head>

<body class="bg-slate-50 font-sans p-4 md:p-8 flex flex-col items-center min-h-screen">
    <div class="w-full max-w-7xl mx-auto">
        <header class="mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-center text-slate-800">Disk Scheduling Algorithm Simulation
            </h1>
            <p class="text-center text-slate-600 mt-2">Visualize and compare FCFS, SSTF, SCAN, C-SCAN, LOOK, C-LOOK, and
                HDSA algorithms. Dashed lines show non-servicing head movement.</p>
        </header>
        <div class="section-card">
            <h2 class="text-xl font-semibold text-slate-700 mb-5 text-center">Configuration</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-5 mb-5">
                <div class="flex flex-col"> <label for="algorithm-select">Algorithm (for Details)</label> <select
                        id="algorithm-select" class="mt-1">
                        <option value="FCFS">FCFS</option>
                        <option value="SSTF">SSTF</option>
                        <option value="SCAN">SCAN</option>
                        <option value="C-SCAN">C-SCAN</option>
                        <option value="LOOK">LOOK</option>
                        <option value="C-LOOK">C-LOOK</option>
                        <option value="HDSA">HDSA</option>
                    </select> </div>
                <div class="flex flex-col"> <label for="start-head">Start Head Position</label> <input type="number"
                        id="start-head" value="53" min="0" class="mt-1"> </div>
                <div class="flex flex-col"> <label for="max-cylinder">Max Cylinder</label> <input type="number"
                        id="max-cylinder" value="199" min="0" class="mt-1"> </div>
                <div class="flex flex-col"> <label for="animation-speed-select">Indiv. Animation Speed</label> <select
                        id="animation-speed-select" class="mt-1">
                        <option value="4">Slow</option>
                        <option value="2" selected>Medium</option>
                        <option value="1">Fast</option>
                        <option value="0.5">Very Fast</option>
                    </select> </div>
            </div>

            <div class="queue-input-mode-container">
                <label class="mb-2 font-medium">Request Queue Input Mode:</label>
                <div class="flex gap-4">
                    <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="queue_mode"
                            value="manual" id="queue-mode-manual" checked> Manual Input</label>
                    <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="queue_mode"
                            value="generate" id="queue-mode-generate"> Generate Queue</label>
                </div>
            </div>
            <div id="manual-queue-section">
                <div class="flex flex-col md:flex-row items-end gap-4">
                    <div class="flex flex-col w-full md:flex-grow"> <label for="request-queue-input">Request Queue
                            (comma-separated)</label> <input type="text" id="request-queue-input"
                            placeholder="e.g., 98, 183, 37, 122, 14, 124, 65, 67" class="mt-1"> </div>
                </div>
            </div>
            <div id="generate-queue-section" class="hidden">
                <div class="queue-gen-controls">
                    <div class="flex flex-col"> <label for="generate-type-select">Generation Type</label> <select
                            id="generate-type-select" class="mt-1">
                            <option value="uniform">Uniform Random</option>
                            <option value="sequential">Sequential</option>
                            <option value="clustered">Clustered (Dense)</option>
                            <option value="mixed">Mixed (Uniform+Clustered)</option>
                        </select> </div>
                    <div class="flex flex-col"> <label for="generate-num-requests">Number of Requests</label> <input
                            type="number" id="generate-num-requests" value="20" min="1" class="mt-1"> </div>
                    <div class="flex flex-col" id="cluster-options" class="hidden"> <label
                            for="generate-num-clusters">Desired Clusters</label> <input type="number"
                            id="generate-num-clusters" value="3" min="1" class="mt-1"> </div>
                    <div class="flex flex-col"> <button id="generate-queue-button" class="btn btn-green w-full"> <span
                                class="lucide"></span> Generate & Use </button> </div>
                </div>
            </div>
            <div class="flex justify-center mt-6">
                <button id="update-queue-button" class="btn btn-indigo"> <span class="lucide"></span> Update Simulation
                </button>
            </div>
            <p id="message-box" class="font-medium mt-4 text-sm text-center"></p>
        </div>

        <div class="section-card algo-selection-container">
            <h3 class="text-lg font-semibold text-slate-700 mb-3 text-center">Select Algorithms to Compare / Visualize
            </h3>
            <div id="algo-selection-grid" class="algo-selection-grid"> <!-- Checkboxes added by JS --> </div>
            <p class="text-xs text-slate-500 text-center mt-2">Changes here will reset visualizations and calculations.
            </p>
        </div>

        <!-- Request Queue Scatter Plot Section -->
        <div class="section-card">
            <h2 class="text-xl font-semibold text-slate-700 mb-4 text-center">Request Queue Visualization</h2>
            <p class="text-center text-sm text-slate-500 mb-4">Scatter plot showing cylinder requests over their arrival
                sequence (index).</p>
            <div class="queue-plot-container visualization-box">
                <canvas id="queue-plot-canvas"></canvas>
                <span class="axis-label x-axis-label">Cylinder Number</span>
                <span class="axis-label y-axis-label">Request Sequence Index</span>
            </div>
        </div>

        <div class="flex justify-center items-center flex-wrap gap-4 my-8">
            <button id="start-button" class="btn btn-primary btn-lg"> <span class="lucide"></span> Animate Individual
                Traces</button>
            <button id="animate-combined-button" class="btn btn-teal btn-lg"> <span class="lucide"></span> Animate
                Combined Plot</button>
            <button id="reset-button" class="btn btn-secondary"> <span class="lucide"></span> Reset Defaults </button>
        </div>
        <div class="section-card">
            <h2 class="text-lg font-semibold text-slate-700 mb-4">Details (Selected Algorithm: <span
                    id="selected-algo-details-title" class="font-bold text-indigo-600">FCFS</span>)</h2>
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm">
                <div><strong class="text-slate-600">Initial Queue:</strong> <span id="request-sequence-display"
                        class="font-mono block break-words mt-1"></span></div>
                <div><strong class="text-slate-600">Serviced Request Order:</strong> <span id="serviced-order-display"
                        class="font-mono block break-words mt-1"></span></div>
                <div><strong class="text-slate-600">Total Head Movement:</strong> <span id="total-movement-display"
                        class="font-mono text-indigo-600 font-semibold block mt-1">0</span></div>
            </div>
        </div>
        <div class="section-card">
            <h2 class="text-xl font-semibold text-slate-700 mb-4 text-center">All-in-One Visualization</h2>
            <p class="text-center text-sm text-slate-500 mb-4">Selected algorithms animated simultaneously. Speed is
                inversely proportional to total head movement.</p>
            <div class="all-in-one-container visualization-box">
                <canvas id="all-in-one-canvas"></canvas>
                <span class="axis-label x-axis-label">Cylinder Number</span>
                <span class="axis-label y-axis-label">Path Step Number</span>
            </div>
            <div id="all-in-one-legend" class="legend"></div>
        </div>
        <div class="section-card">
            <h2 class="text-xl font-semibold text-slate-700 mb-6 text-center">Individual Head Path Traces</h2>
            <div class="trace-grid"></div>
        </div>
        <div class="section-card comparison-container">
            <h2 class="text-xl font-semibold text-slate-700 mb-6 text-center">Algorithm Comparison</h2>
            <div class="mb-6">
                <div class="flex justify-center items-center flex-wrap gap-3 mb-5">
                    <button id="compare-movement-btn" class="metric-button active">Total Movement</button>
                    <button id="compare-avgSeek-btn" class="metric-button">Avg Seek</button>
                    <button id="compare-maxSeek-btn" class="metric-button">Max Seek</button>
                    <button id="compare-stdDevSeek-btn" class="metric-button">StdDev Seek</button>
                    <button id="compare-throughput-btn" class="metric-button">Throughput</button>
                </div>
                <div class="flex justify-center items-center flex-wrap gap-3 mb-5">
                    <button id="sort-comparison-btn" class="btn btn-secondary sort-button">
                        <span class="lucide"></span> Sort Ascending
                    </button>
                </div>
                <div class="relative"> <canvas id="comparison-graph-canvas"></canvas> </div>
            </div>
            <div>
                <h3 class="text-lg font-semibold text-slate-700 mb-4 text-center">Comparison Summary</h3>
                <div class="overflow-x-auto">
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Algorithm</th>
                                <th>Total Move</th>
                                <th>Avg Seek</th>
                                <th>Max Seek</th>
                                <th>StdDev Seek</th>
                                <th>Throughput</th>
                            </tr>
                        </thead>
                        <tbody id="comparison-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <footer class="w-full max-w-7xl mx-auto text-center text-sm text-slate-500 py-6 mt-8"> Disk Scheduling Simulator -
        Review and check algorithm behavior carefully. Note: Avg Seek Time and Throughput are calculated based on number
        of requests serviced, not total path steps. </footer>

    <script>
        // --- DOM Elements ---
        const getEl = (id) => document.getElementById(id);
        const algorithmSelect = getEl('algorithm-select'), startHeadInput = getEl('start-head'), maxCylinderInput = getEl('max-cylinder'), requestQueueInput = getEl('request-queue-input'), updateQueueButton = getEl('update-queue-button'), startButton = getEl('start-button'), resetButton = getEl('reset-button'), requestSequenceDisplay = getEl('request-sequence-display'), servicedOrderDisplay = getEl('serviced-order-display'), totalMovementDisplay = getEl('total-movement-display'), messageBox = getEl('message-box'), traceGridContainer = document.querySelector('.trace-grid'), selectedAlgoDetailsTitle = getEl('selected-algo-details-title'), comparisonCanvas = getEl('comparison-graph-canvas'), comparisonCtx = comparisonCanvas.getContext('2d'), comparisonTableBody = getEl('comparison-table-body'), animationSpeedSelect = getEl('animation-speed-select'), animateCombinedButton = getEl('animate-combined-button'), allInOneCanvas = getEl('all-in-one-canvas'), allInOneCtx = allInOneCanvas.getContext('2d'), allInOneLegend = getEl('all-in-one-legend'), sortComparisonBtn = getEl('sort-comparison-btn'), algoSelectionGrid = getEl('algo-selection-grid');
        const compareMovementBtn = getEl('compare-movement-btn'), compareAvgSeekBtn = getEl('compare-avgSeek-btn'), compareMaxSeekBtn = getEl('compare-maxSeek-btn'), compareStdDevSeekBtn = getEl('compare-stdDevSeek-btn'), compareThroughputBtn = getEl('compare-throughput-btn');
        const metricButtons = [compareMovementBtn, compareAvgSeekBtn, compareMaxSeekBtn, compareStdDevSeekBtn, compareThroughputBtn];
        const queueModeManualRadio = getEl('queue-mode-manual'), queueModeGenerateRadio = getEl('queue-mode-generate'), manualQueueSection = getEl('manual-queue-section'), generateQueueSection = getEl('generate-queue-section'), generateTypeSelect = getEl('generate-type-select'), generateNumRequestsInput = getEl('generate-num-requests'), clusterOptionsDiv = getEl('cluster-options'), generateNumClustersInput = getEl('generate-num-clusters'), generateQueueButton = getEl('generate-queue-button');
        const queuePlotCanvas = getEl('queue-plot-canvas'); const queuePlotCtx = queuePlotCanvas.getContext('2d');

        // --- Simulation State ---
        let currentRequests = [], initialHeadPosition = 53, maxCylinder = 199, animationTimeout = null, allInOneAnimationId = null, isAnimatingIndividual = false, isAnimatingAllInOne = false, allAlgorithmResults = {}, traceCanvasContexts = {}, maxPathSteps = 0, msPerUnitMovement = 2, currentComparisonMetric = 'movement', isComparisonSorted = false;
        let selectedAlgorithms = ['FCFS', 'SSTF', 'SCAN', 'C-SCAN', 'LOOK', 'C-LOOK', 'HDSA'];
        let liveMovementTrackers = {};
        let currentQueueMode = 'manual'; let generatedQueueString = '';

        // --- Constants ---
        const ALL_ALGORITHMS = ['FCFS', 'SSTF', 'SCAN', 'C-SCAN', 'LOOK', 'C-LOOK', 'HDSA'];
        const DEFAULT_QUEUE_STRING = "98, 183, 37, 122, 14, 124, 65, 67", DEFAULT_START_HEAD = 53, DEFAULT_MAX_CYLINDER = 199, DEFAULT_ANIMATION_SPEED = "2";
        const ALGO_COLORS = { 'FCFS': '#34D399', 'SSTF': '#F87171', 'SCAN': '#60A5FA', 'C-SCAN': '#FACC15', 'LOOK': '#A78BFA', 'C-LOOK': '#FB923C', 'HDSA': '#f472b6' };
        const TRACE_PADDING = 40, TRACE_POINT_RADIUS = 3.5, TRACE_LINE_COLOR = '#3b82f6', TRACE_DASHED_LINE_COLOR = '#60a5fa', TRACE_POINT_COLOR = '#ef4444', TRACE_NON_SERVICE_POINT_COLOR = '#fbbf24', TRACE_GRID_COLOR = '#e2e8f0', TRACE_AXIS_COLOR = '#64748b', TRACE_LABEL_COLOR = '#475569', TRACE_CYLINDER_LABEL_COLOR = '#1e40af', DASH_PATTERN = [4, 4];
        const COMP_PADDING = 90, COMP_BAR_COLOR = '#818cf8', COMP_BEST_BAR_COLOR = '#22c55e', COMP_AXIS_COLOR = '#334155', COMP_LABEL_COLOR = '#1e293b', COMP_GRID_COLOR = '#e2e8f0', COMP_BAR_VALUE_COLOR = '#4338ca';
        const AIO_PADDING = 50, AIO_BG_COLOR = '#1e293b', AIO_AXIS_COLOR = '#94a3b8', AIO_GRID_COLOR = '#475569', AIO_LABEL_COLOR = '#e2e8f0', AIO_POINT_RADIUS = 3.5, AIO_LINE_WIDTH = 1.8, AIO_START_POINT_COLOR = '#f1f5f9', AIO_ALPHA = 0.75;
        const MIN_STEP_DURATION = 30, MAX_STEP_DURATION = 800, AIO_BASE_TIME_SCALE = 50;
        const METRIC_CONFIG = { movement: { lowerIsBetter: true, label: 'Total Movement', precision: 0, yAxisLabel: "Total Head Movement" }, avgSeek: { lowerIsBetter: true, label: 'Avg Seek', precision: 2, yAxisLabel: "Avg Seek Time (per Request)" }, maxSeek: { lowerIsBetter: true, label: 'Max Seek', precision: 0, yAxisLabel: "Maximum Seek Time" }, stdDevSeek: { lowerIsBetter: true, label: 'StdDev Seek', precision: 2, yAxisLabel: "Std Dev Seek Time" }, throughput: { lowerIsBetter: false, label: 'Throughput', precision: 4, yAxisLabel: "Throughput (Reqs / Movement)" } };
        const QPLOT_PADDING = 40; const QPLOT_POINT_RADIUS = 2.5; const QPLOT_POINT_COLOR = '#3b82f6'; const QPLOT_GRID_COLOR = '#e2e8f0'; const QPLOT_AXIS_COLOR = '#64748b'; const QPLOT_LABEL_COLOR = '#475569';

        // --- Queue Generation Functions (Including REVISED Clustered with C/N Centers) ---
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; } }
        function generateUniformRandomJS(maxCyl, numReq) { const q = []; const maxV = Math.max(0, maxCyl); for (let i = 0; i < numReq; ++i) q.push(Math.floor(Math.random() * (maxV + 1))); return q; }
        function generateSequentialJS(maxCyl, numReq) { const q = []; if (maxCyl <= 0) { for (let i = 0; i < numReq; ++i) q.push(0); return q; } const maxStep = Math.max(1, Math.min(Math.floor(maxCyl / 10), 5)); let curr = Math.floor(Math.random() * (maxCyl + 1)); let inc = Math.random() < 0.5; for (let i = 0; i < numReq; ++i) { curr = Math.max(0, Math.min(maxCyl, curr)); q.push(curr); if (i < numReq - 1) { let next = curr; let att = 0; do { const mov = Math.floor(Math.random() * maxStep) + 1; let pot = inc ? curr + mov : curr - mov; let b = false; if (pot >= maxCyl) { pot = maxCyl; if (inc) { inc = false; b = true; } } else if (pot <= 0) { pot = 0; if (!inc) { inc = true; b = true; } } next = pot; att++; } while (next === curr && maxCyl > 0 && att < 5); curr = next; } } return q; }
        const randomNormalBM = (() => { let z2 = null; const epsilon = 1e-10; return () => { if (z2 !== null) { const tmp = z2; z2 = null; return tmp; } let u1 = 0, u2 = 0; while (u1 < epsilon) u1 = Math.random(); while (u2 < epsilon) u2 = Math.random(); const mag = Math.sqrt(-2.0 * Math.log(u1)); const z1 = mag * Math.cos(2.0 * Math.PI * u2); z2 = mag * Math.sin(2.0 * Math.PI * u2); return z1; }; })();
        // REVISED Clustered Generator (C/N Centers, No Shuffle)
        function generateClusteredJS(maxCyl, numReq, desiredNumClusters) {
            const queue = []; if (numReq <= 0) return queue; maxCyl = Math.max(0, maxCyl);
            const numClusters = Math.max(1, Math.min(desiredNumClusters, numReq));
            const requestsPerCluster = Math.floor(numReq / numClusters); const remainingRequests = numReq % numClusters;

            // --- Determine Cluster Center Placement (C/N Basis with Separation) ---
            const clusterCenters = [];
            const approxSegmentWidth = (numClusters > 0) ? (maxCyl + 1) / numClusters : 0.0;
            for (let i = 0; i < numClusters; ++i) {
                const idealCenterDouble = (i + 0.5) * approxSegmentWidth;
                const idealCenter = Math.round(idealCenterDouble);
                const centerOffsetRange = Math.round(approxSegmentWidth * 0.10); // Small offset range
                const centerOffset = Math.floor(Math.random() * (centerOffsetRange * 2 + 1)) - centerOffsetRange;
                let actualCenterX = idealCenter + centerOffset;
                actualCenterX = Math.max(0, Math.min(maxCyl, actualCenterX)); // Clamp center X
                clusterCenters.push(actualCenterX);
            }
            // No shuffling centers preserves Y-axis grouping per cluster

            // --- Generate Requests with Density around Centers ---
            const stdDev = Math.max(1.0, approxSegmentWidth / 6.0); // Std dev based on segment width
            console.log(`Clustered Gen: Centers=`, clusterCenters, `StdDev=${stdDev.toFixed(2)}`);

            let requestsGenerated = 0;
            for (let i = 0; i < numClusters; ++i) { // Iterate through clusters IN ORDER
                const clusterCenterX = clusterCenters[i];
                let currentRequestsInCluster = requestsPerCluster + (i < remainingRequests ? 1 : 0);
                // Ensure not generating more than numReq total
                currentRequestsInCluster = Math.min(currentRequestsInCluster, numReq - requestsGenerated);

                for (let j = 0; j < currentRequestsInCluster; ++j) {
                    const offset = randomNormalBM() * stdDev;
                    let requestCyl = Math.round(clusterCenterX + offset);
                    requestCyl = Math.max(0, Math.min(maxCyl, requestCyl)); // Clamp point X
                    queue.push(requestCyl); // Add points for this cluster sequentially
                    requestsGenerated++;
                }
            }
            while (queue.length < numReq) { queue.push(Math.floor(Math.random() * (maxCyl + 1))); }
            if (queue.length > numReq) { queue.length = numReq; }
            // DO NOT SHUFFLE THE FINAL QUEUE HERE
            return queue;
        }
        // REVISED Mixed Generator (No Final Shuffle)
        function generateMixedJS(maxCyl, numReq) {
            let queue = [];
            const numRandom = Math.floor(numReq * 0.6);
            const numClustered = numReq - numRandom;
            let randomPart = [], clusteredPart = [];

            if (numRandom > 0) {
                randomPart = generateUniformRandomJS(maxCyl, numRandom);
                shuffleArray(randomPart); // Shuffle the random part internally is fine
            }
            if (numClustered > 0) {
                let clustersForMixed = Math.max(1, Math.min(numClustered, Math.floor(numClustered / 5) + 1));
                clusteredPart = generateClusteredJS(maxCyl, numClustered, clustersForMixed); // This part is now ordered by cluster
            }
            // Combine, placing random first then clustered
            queue = randomPart.concat(clusteredPart);

            // Ensure correct size
            while (queue.length < numReq) { queue.push(Math.floor(Math.random() * (Math.max(0, maxCyl) + 1))); }
            if (queue.length > numReq) { queue.length = numReq; }
            // DO NOT SHUFFLE THE COMBINED QUEUE
            return queue;
        }

        // --- Initialization ---
        function initializeSimulation(resetToDefaults = false, fromGenerateButton = false) {
            console.log("Initializing simulation. Reset:", resetToDefaults, "From Generate:", fromGenerateButton);
            clearTimeout(animationTimeout); cancelAnimationFrame(allInOneAnimationId); isAnimatingIndividual = false; isAnimatingAllInOne = false; isComparisonSorted = false; liveMovementTrackers = {}; updateSortButtonState(); disableUI(false); startButton.innerHTML = '<span class="lucide"></span> Animate Individual Traces'; animateCombinedButton.innerHTML = '<span class="lucide"></span> Animate Combined Plot'; allAlgorithmResults = {}; traceCanvasContexts = {}; maxPathSteps = 0; traceGridContainer.innerHTML = ''; allInOneCtx.clearRect(0, 0, allInOneCanvas.width, allInOneCanvas.height); allInOneLegend.innerHTML = ''; queuePlotCtx.clearRect(0, 0, queuePlotCanvas.width, queuePlotCanvas.height); showMessage('');

            if (resetToDefaults) {
                requestQueueInput.value = DEFAULT_QUEUE_STRING; maxCylinderInput.value = DEFAULT_MAX_CYLINDER; startHeadInput.value = DEFAULT_START_HEAD; algorithmSelect.value = 'FCFS'; animationSpeedSelect.value = DEFAULT_ANIMATION_SPEED;
                currentQueueMode = 'manual'; queueModeManualRadio.checked = true; toggleQueueInputMode();
                generateNumRequestsInput.value = 20; generateTypeSelect.value = 'uniform'; generateNumClustersInput.value = 3; toggleClusterOptions();
                generatedQueueString = ''; selectedAlgorithms = [...ALL_ALGORITHMS]; updateAlgorithmCheckboxes();
            } else {
                selectedAlgorithms = ALL_ALGORITHMS.filter(algoName => getEl(`algo-checkbox-${algoName}`)?.checked);
                if (selectedAlgorithms.length === 0) { showMessage("Warning: No algorithms selected. Select at least one.", true); selectedAlgorithms = [ALL_ALGORITHMS[0]]; updateAlgorithmCheckboxes(); }
                if (!fromGenerateButton) { currentQueueMode = queueModeGenerateRadio.checked ? 'generate' : 'manual'; toggleQueueInputMode(); }
            }

            let queueString = '';
            if (currentQueueMode === 'manual') {
                queueString = requestQueueInput.value.trim();
                if (!queueString && !resetToDefaults) { showMessage("Manual queue empty, using default: " + DEFAULT_QUEUE_STRING); queueString = DEFAULT_QUEUE_STRING; requestQueueInput.value = queueString; }
                else if (!queueString && resetToDefaults) { queueString = DEFAULT_QUEUE_STRING; }
            } else {
                // If generate mode is active AND the generate button wasn't just clicked OR if the string is empty, generate now
                if (fromGenerateButton || !generatedQueueString) { handleGenerateQueue(false); } // Regenerate if forced or empty
                queueString = generatedQueueString; requestQueueInput.value = queueString; // Use stored/newly generated
            }

            msPerUnitMovement = parseFloat(animationSpeedSelect.value) || 2; const selectedAlgorithmForDetails = algorithmSelect.value; initialHeadPosition = parseInt(startHeadInput.value, 10); maxCylinder = parseInt(maxCylinderInput.value, 10); selectedAlgoDetailsTitle.textContent = selectedAlgorithmForDetails; let isValid = true;
            if (isNaN(maxCylinder) || maxCylinder < 0) { showMessage("Error: Max Cylinder must be a non-negative number.", true); isValid = false; maxCylinder = Math.max(0, maxCylinder || 0); }
            if (isNaN(initialHeadPosition) || initialHeadPosition < 0 || initialHeadPosition > maxCylinder) { showMessage(`Error: Start Head Position must be between 0 and ${maxCylinder}.`, true); isValid = false; }

            currentRequests = queueString.split(',').map(s => s.trim()).filter(s => s !== '').map(Number);
            if (currentRequests.some(isNaN)) { showMessage("Error: Request queue contains non-numeric values.", true); isValid = false; }
            const originalLength = currentRequests.length;
            currentRequests = currentRequests.filter(req => req >= 0 && req <= maxCylinder);
            if (currentRequests.length !== originalLength && isValid && queueString !== DEFAULT_QUEUE_STRING) { showMessage(`Note: Some generated/input requests were filtered out as they are outside the 0-${maxCylinder} range.`); }
            if (currentRequests.length === 0 && isValid && queueString !== DEFAULT_QUEUE_STRING && !fromGenerateButton) { showMessage(`Warning: No valid requests in the queue within the 0-${maxCylinder} range. Using empty queue.`); }
            requestSequenceDisplay.textContent = currentRequests.join(', ') || 'None';
            if (!isValid) { disableSimulation(); return; }

            let tempMaxPathSteps = 0; const numRequests = currentRequests.length;
            selectedAlgorithms.forEach(algoName => {
                const { servicedOrder, totalMovement, fullPath, isServiceStop } = getServicingOrder(algoName, initialHeadPosition, [...currentRequests], maxCylinder);
                const seekTimes = calculateSeekTimes(fullPath);
                const maxSeekTime = seekTimes.length > 0 ? Math.max(...seekTimes) : 0;
                const avgSeekTime = numRequests > 0 ? (totalMovement / numRequests) : 0;
                const stdDevSeekTime = calculateStdDev(seekTimes);
                const throughput = numRequests > 0 && totalMovement > 0 ? (numRequests / totalMovement) : (numRequests > 0 ? Infinity : 0);
                allAlgorithmResults[algoName] = { label: algoName, requests: [...currentRequests], servicedOrder, totalMovement, fullPath, isServiceStop, seekTimes, avgSeekTime, maxSeekTime, stdDevSeekTime, throughput };
                tempMaxPathSteps = Math.max(tempMaxPathSteps, fullPath.length);
                const { canvas, ctx, liveMovementEl } = createCanvasForAlgo(algoName, totalMovement);
                traceCanvasContexts[algoName] = { canvas, ctx };
                liveMovementTrackers[algoName] = liveMovementEl;
                const legendItem = document.createElement('div'); legendItem.className = 'legend-item'; legendItem.innerHTML = `<span class="legend-color-box" style="background-color: ${hexToRgba(ALGO_COLORS[algoName], AIO_ALPHA)};"></span> ${algoName}`; allInOneLegend.appendChild(legendItem);
            });
            maxPathSteps = tempMaxPathSteps; console.log("Max Path Steps:", maxPathSteps);
            updateDetailsDisplay(selectedAlgorithmForDetails);

            setupQueuePlotCanvas(); drawQueuePlotPoints(); // Draw queue plot

            requestAnimationFrame(() => { // Draw algo traces etc.
                selectedAlgorithms.forEach(algoName => { if (traceCanvasContexts[algoName]) { const { canvas, ctx } = traceCanvasContexts[algoName]; if (canvas.offsetWidth > 0 && canvas.offsetHeight > 0) { setupTraceCanvas(canvas, ctx, maxPathSteps, maxCylinder); drawInitialTracePoint(ctx, initialHeadPosition, maxPathSteps, maxCylinder, canvas.width, canvas.height); } else { console.warn(`Individual canvas ${algoName} has zero dimensions.`); } } });
                if (selectedAlgorithms.length > 0 && allInOneCanvas.offsetWidth > 0 && allInOneCanvas.offsetHeight > 0) { setupAllInOneCanvas(maxPathSteps, maxCylinder); drawAllInOneInitialPoint(initialHeadPosition, maxPathSteps, maxCylinder); } else { console.warn("All-in-one canvas has zero dimensions or no algos selected."); }
                drawComparisonGraph(); populateComparisonTable();
            });
            const hasRequests = currentRequests.length > 0; const canCompare = selectedAlgorithms.length >= 1;
            disableUI(!(hasRequests && canCompare));
            if (!hasRequests && currentQueueMode === 'generate' && !resetToDefaults) showMessage("Generated queue resulted in 0 valid requests.");
            else if (!hasRequests) showMessage("No requests to visualize or animate.");
            else if (!canCompare) showMessage("No algorithms selected for comparison/visualization.");
        }

        // --- Disable Simulation / UI ---
        function disableSimulation() { disableUI(true); traceGridContainer.innerHTML = '<p class="text-center text-slate-500 col-span-full py-10">Simulation disabled due to invalid input. Please correct the configuration.</p>'; allInOneCtx.clearRect(0, 0, allInOneCanvas.width, allInOneCanvas.height); allInOneLegend.innerHTML = ''; comparisonCtx.clearRect(0, 0, comparisonCanvas.width, comparisonCanvas.height); queuePlotCtx.clearRect(0, 0, queuePlotCanvas.width, queuePlotCanvas.height); comparisonTableBody.innerHTML = `<tr><td colspan="${Object.keys(METRIC_CONFIG).length + 1}" class="text-center text-slate-500 py-4">Invalid input configuration</td></tr>`; requestSequenceDisplay.textContent = 'Invalid Input'; servicedOrderDisplay.textContent = 'N/A'; totalMovementDisplay.textContent = 'N/A'; }
        function disableUI(disable) { const isDisabled = !!disable; const hasRequests = currentRequests.length > 0; const canCompare = selectedAlgorithms.length >= 1; const canAnimateCompare = selectedAlgorithms.length > 1; startButton.disabled = isDisabled || !hasRequests || !canCompare || isAnimatingAllInOne; animateCombinedButton.disabled = isDisabled || !hasRequests || !canAnimateCompare || isAnimatingIndividual; resetButton.disabled = isDisabled; updateQueueButton.disabled = isDisabled; algorithmSelect.disabled = isDisabled; startHeadInput.disabled = isDisabled; maxCylinderInput.disabled = isDisabled; animationSpeedSelect.disabled = isDisabled; metricButtons.forEach(btn => btn.disabled = isDisabled || !canCompare); sortComparisonBtn.disabled = isDisabled || !canCompare; ALL_ALGORITHMS.forEach(algoName => { const cb = getEl(`algo-checkbox-${algoName}`); if (cb) cb.disabled = isDisabled; }); queueModeManualRadio.disabled = isDisabled; queueModeGenerateRadio.disabled = isDisabled; generateTypeSelect.disabled = isDisabled; generateNumRequestsInput.disabled = isDisabled; generateNumClustersInput.disabled = isDisabled; generateQueueButton.disabled = isDisabled; requestQueueInput.disabled = isDisabled || currentQueueMode === 'generate'; requestQueueInput.readOnly = isDisabled || currentQueueMode === 'generate'; }

        // --- UI Toggles for Queue Input ---
        function toggleQueueInputMode() { if (queueModeGenerateRadio.checked) { currentQueueMode = 'generate'; manualQueueSection.classList.add('hidden'); generateQueueSection.classList.remove('hidden'); requestQueueInput.readOnly = true; requestQueueInput.disabled = true; requestQueueInput.value = generatedQueueString || ''; } else { currentQueueMode = 'manual'; manualQueueSection.classList.remove('hidden'); generateQueueSection.classList.add('hidden'); requestQueueInput.readOnly = false; requestQueueInput.disabled = false; } disableUI(isAnimatingIndividual || isAnimatingAllInOne); }
        function toggleClusterOptions() { if (generateTypeSelect.value === 'clustered') { clusterOptionsDiv.classList.remove('hidden'); } else { clusterOptionsDiv.classList.add('hidden'); } }

        // --- Canvas Creation, Update Details, Drawing Functions (Trace/Axes/Map/Initial/Segment), Metric Calcs ---
        function createCanvasForAlgo(algoName, totalMovement) { const traceItem = document.createElement('div'); traceItem.className = 'trace-item'; traceItem.innerHTML = `<h3>${algoName}</h3><p class="movement-info">Total: <strong>${totalMovement}</strong></p><p class="live-movement-display" id="live-move-${algoName}"></p><div class="visualization-box canvas-container w-full"><canvas id="trace-canvas-${algoName}" class="trace-canvas"></canvas><span class="axis-label y-axis-label">Path Step Number</span><span class="axis-label x-axis-label">Cylinder Number</span></div>`; traceGridContainer.appendChild(traceItem); const canvas = traceItem.querySelector('canvas'); const ctx = canvas.getContext('2d'); const liveMovementEl = traceItem.querySelector(`#live-move-${algoName}`); return { canvas, ctx, liveMovementEl }; }
        function updateDetailsDisplay(algoName) { const result = allAlgorithmResults[algoName]; selectedAlgoDetailsTitle.textContent = algoName; if (result) { servicedOrderDisplay.textContent = result.servicedOrder.join(', ') || 'None'; totalMovementDisplay.textContent = result.totalMovement.toFixed(0); } else { servicedOrderDisplay.textContent = 'N/A (Not Selected)'; totalMovementDisplay.textContent = 'N/A'; } }
        function setupTraceCanvas(canvas, ctx, maxTotalPathSteps, maxCylValue) { const currentWidth = canvas.offsetWidth; const currentHeight = canvas.offsetHeight; if (currentWidth > 0 && currentHeight > 0) { canvas.width = currentWidth; canvas.height = currentHeight; ctx.clearRect(0, 0, canvas.width, canvas.height); drawTraceAxes(ctx, canvas.width, canvas.height, maxTotalPathSteps, maxCylValue); } else { console.warn("Canvas dimensions not available for setup:", canvas.id); } }
        function drawTraceAxes(ctx, width, height, maxSteps, maxCyl) { ctx.save(); ctx.strokeStyle = TRACE_AXIS_COLOR; ctx.fillStyle = TRACE_LABEL_COLOR; ctx.lineWidth = 1; ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const plotHeight = height - 2 * TRACE_PADDING; const plotWidth = width - 2 * TRACE_PADDING; ctx.beginPath(); ctx.moveTo(TRACE_PADDING, TRACE_PADDING); ctx.lineTo(TRACE_PADDING, height - TRACE_PADDING); ctx.stroke(); ctx.beginPath(); ctx.moveTo(TRACE_PADDING, height - TRACE_PADDING); ctx.lineTo(width - TRACE_PADDING, height - TRACE_PADDING); ctx.stroke(); const yLabelInterval = Math.max(1, Math.ceil(maxSteps / 15)); for (let i = 0; i < maxSteps; i++) { const y = mapToTraceCanvas(i, 0, maxSteps, maxCyl, width, height).y; if (i % yLabelInterval === 0 || i === maxSteps - 1) { ctx.fillStyle = TRACE_LABEL_COLOR; ctx.textAlign = 'right'; ctx.fillText(i, TRACE_PADDING - 8, y); } ctx.strokeStyle = TRACE_GRID_COLOR; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(TRACE_PADDING + 1, y); ctx.lineTo(width - TRACE_PADDING, y); ctx.stroke(); } const numXTicks = Math.min(10, Math.floor(plotWidth / 50)); ctx.textAlign = 'center'; ctx.textBaseline = 'top'; for (let i = 0; i <= numXTicks; i++) { const cylinder = Math.round((i / numXTicks) * maxCyl); const x = mapToTraceCanvas(0, cylinder, maxSteps, maxCyl, width, height).x; ctx.strokeStyle = TRACE_AXIS_COLOR; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(x, height - TRACE_PADDING); ctx.lineTo(x, height - TRACE_PADDING + 5); ctx.stroke(); ctx.fillStyle = TRACE_LABEL_COLOR; ctx.fillText(cylinder, x, height - TRACE_PADDING + 8); } ctx.restore(); }
        function mapToTraceCanvas(stepIndex, cylinder, maxTotalPathSteps, maxCyl, canvasWidth, canvasHeight) { const plotWidth = canvasWidth - 2 * TRACE_PADDING; const plotHeight = canvasHeight - 2 * TRACE_PADDING; const yFactor = (maxTotalPathSteps <= 1) ? 0 : stepIndex / (maxTotalPathSteps - 1); const y = TRACE_PADDING + yFactor * plotHeight; const x = TRACE_PADDING + (cylinder / Math.max(1, maxCyl)) * plotWidth; return { x: Math.max(TRACE_PADDING, Math.min(canvasWidth - TRACE_PADDING, x)), y: Math.max(TRACE_PADDING, Math.min(canvasHeight - TRACE_PADDING, y)) }; }
        function drawTraceSegment(ctx, stepIndex, prevCylinder, currentCylinder, maxTotalPathSteps, maxCyl, width, height, isServiceEndPoint) { if (width <= 0 || height <= 0 || stepIndex === 0) return; const startPoint = mapToTraceCanvas(stepIndex - 1, prevCylinder, maxTotalPathSteps, maxCyl, width, height); const endPoint = mapToTraceCanvas(stepIndex, currentCylinder, maxTotalPathSteps, maxCyl, width, height); ctx.save(); ctx.lineWidth = 1.5; if (isServiceEndPoint) { ctx.setLineDash([]); ctx.strokeStyle = TRACE_LINE_COLOR; } else { ctx.setLineDash(DASH_PATTERN); ctx.strokeStyle = TRACE_DASHED_LINE_COLOR; } ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(endPoint.x, endPoint.y); ctx.stroke(); ctx.setLineDash([]); let pointColor = isServiceEndPoint ? TRACE_POINT_COLOR : TRACE_NON_SERVICE_POINT_COLOR; ctx.fillStyle = pointColor; ctx.beginPath(); ctx.arc(endPoint.x, endPoint.y, TRACE_POINT_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = TRACE_CYLINDER_LABEL_COLOR; ctx.font = '9px Inter, sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const labelOffsetX = 5; const labelOffsetY = (endPoint.y < startPoint.y) ? 5 : -5; ctx.fillText(currentCylinder, endPoint.x + labelOffsetX, endPoint.y + labelOffsetY); ctx.restore(); }
        function drawInitialTracePoint(ctx, cylinder, maxTotalPathSteps, maxCyl, width, height) { if (width <= 0 || height <= 0) return; const point = mapToTraceCanvas(0, cylinder, maxTotalPathSteps, maxCyl, width, height); ctx.save(); ctx.fillStyle = TRACE_NON_SERVICE_POINT_COLOR; ctx.beginPath(); ctx.arc(point.x, point.y, TRACE_POINT_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = TRACE_CYLINDER_LABEL_COLOR; ctx.font = 'bold 10px Inter, sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; ctx.fillText(`Start: ${cylinder}`, point.x + 5, point.y - 5); ctx.restore(); }
        function calculateSeekTimes(fullPath) { const seekTimes = []; for (let i = 1; i < fullPath.length; i++) { seekTimes.push(Math.abs(fullPath[i] - fullPath[i - 1])); } return seekTimes; }
        function calculateStdDev(dataArray) { if (!dataArray || dataArray.length === 0) return 0; const n = dataArray.length; const mean = dataArray.reduce((a, b) => a + b, 0) / n; const variance = dataArray.reduce((a, b) => a + (b - mean) ** 2, 0) / n; return Math.sqrt(variance); }
        function runSSTFOnSubset(subsetReqs, startPos) { let currentPos = startPos; let pathSubset = [startPos]; let movementSubset = 0; let mutableReqs = [...subsetReqs]; while (mutableReqs.length > 0) { let closestReqIndex = -1; let minDistance = Infinity; mutableReqs.forEach((req, index) => { const distance = Math.abs(req - currentPos); if (distance < minDistance) { minDistance = distance; closestReqIndex = index; } else if (distance === minDistance && req < mutableReqs[closestReqIndex]) { closestReqIndex = index; } }); if (closestReqIndex !== -1) { const closestReq = mutableReqs[closestReqIndex]; movementSubset += minDistance; currentPos = closestReq; pathSubset.push(currentPos); mutableReqs.splice(closestReqIndex, 1); } else { console.error("SSTF Subset Error"); break; } } return { pathSubset, movementSubset, lastPosition: currentPos }; }

        // --- Disk Scheduling Algorithm Logic (HDSA added) ---
        function getServicingOrder(algorithm, startHead, reqs, maxCyl) { let currentHead = startHead; let requestsCopy = [...reqs]; let servicedOrder = []; let fullPath = [startHead]; let isServiceStop = [false]; let totalMovement = 0; if (reqs.length === 0) { return { servicedOrder: [], totalMovement: 0, fullPath: [startHead], isServiceStop: [false] }; } let sortedReqs = [...reqs].sort((a, b) => a - b); switch (algorithm) { case 'FCFS': { requestsCopy.forEach(req => { totalMovement += Math.abs(req - currentHead); currentHead = req; servicedOrder.push(req); fullPath.push(req); isServiceStop.push(true); }); break; } case 'SSTF': { let r = [...requestsCopy]; while (r.length > 0) { let ci = -1, md = Infinity; r.forEach((q, i) => { const d = Math.abs(q - currentHead); if (d < md) { md = d; ci = i; } else if (d === md && q < r[ci]) { ci = i; } }); if (ci !== -1) { const c = r[ci]; totalMovement += md; currentHead = c; servicedOrder.push(c); fullPath.push(c); isServiceStop.push(true); r.splice(ci, 1); } else break; } break; } case 'SCAN': { let dir, rl = sortedReqs.some(r => r <= startHead), rr = sortedReqs.some(r => r >= startHead); if (!rl && rr) dir = 1; else if (rl && !rr) dir = -1; else if (!rl && !rr) dir = 1; else dir = (Math.abs(startHead - 0) <= Math.abs(maxCyl - startHead)) ? -1 : 1; let sReq = [...sortedReqs]; while (sReq.length > 0) { if (dir === 1) { let t = sReq.filter(r => r >= currentHead).sort((a, b) => a - b); t.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); sReq.splice(sReq.indexOf(q), 1); }); if (sReq.length > 0) { if (currentHead !== maxCyl) { totalMovement += Math.abs(maxCyl - currentHead); currentHead = maxCyl; fullPath.push(currentHead); isServiceStop.push(false); } dir = -1; } else break; } else { let t = sReq.filter(r => r <= currentHead).sort((a, b) => b - a); t.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); sReq.splice(sReq.indexOf(q), 1); }); if (sReq.length > 0) { if (currentHead !== 0) { totalMovement += Math.abs(0 - currentHead); currentHead = 0; fullPath.push(currentHead); isServiceStop.push(false); } dir = 1; } else break; } } break; } case 'C-SCAN': { let cReq = [...sortedReqs], rReq = cReq.filter(r => r >= currentHead).sort((a, b) => a - b); rReq.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); cReq.splice(cReq.indexOf(q), 1); }); if (cReq.length > 0) { if (currentHead !== maxCyl) { totalMovement += Math.abs(maxCyl - currentHead); currentHead = maxCyl; fullPath.push(currentHead); isServiceStop.push(false); } totalMovement += maxCyl; currentHead = 0; fullPath.push(currentHead); isServiceStop.push(false); cReq.sort((a, b) => a - b).forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); }); } break; } case 'LOOK': { const minR = sortedReqs.length > 0 ? sortedReqs[0] : startHead; const maxR = sortedReqs.length > 0 ? sortedReqs[sortedReqs.length - 1] : startHead; let dir, rl = sortedReqs.some(r => r <= startHead), rr = sortedReqs.some(r => r >= startHead); if (!rl && rr) dir = 1; else if (rl && !rr) dir = -1; else if (!rl && !rr) dir = 1; else dir = (startHead <= (minR + maxR) / 2) ? 1 : -1; if (dir === 1 && !rr) dir = -1; if (dir === -1 && !rl) dir = 1; let lReq = [...sortedReqs]; while (lReq.length > 0) { if (dir === 1) { let t = lReq.filter(r => r >= currentHead).sort((a, b) => a - b); if (t.length === 0) { dir = -1; continue; } t.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); lReq.splice(lReq.indexOf(q), 1); }); dir = -1; } else { let t = lReq.filter(r => r <= currentHead).sort((a, b) => b - a); if (t.length === 0) { dir = 1; continue; } t.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); lReq.splice(lReq.indexOf(q), 1); }); dir = 1; } } break; } case 'C-LOOK': { if (sortedReqs.length === 0) break; let cReq = [...sortedReqs], rP = cReq.filter(r => r >= currentHead).sort((a, b) => a - b); rP.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); cReq.splice(cReq.indexOf(q), 1); }); if (cReq.length > 0) { const jT = cReq[0]; totalMovement += Math.abs(jT - currentHead); currentHead = jT; fullPath.push(currentHead); isServiceStop.push(true); servicedOrder.push(currentHead); cReq.splice(0, 1); cReq.forEach(q => { totalMovement += Math.abs(q - currentHead); currentHead = q; servicedOrder.push(q); fullPath.push(q); isServiceStop.push(true); }); } break; } case 'HDSA': { const qP = reqs.filter(r => r < currentHead).sort((a, b) => a - b); const qQ = reqs.filter(r => r >= currentHead).sort((a, b) => a - b); const loP = qP.length > 0 ? qP[0] : null; const hiQ = qQ.length > 0 ? qQ[qQ.length - 1] : null; const x = loP !== null ? Math.abs(currentHead - loP) : Infinity; const y = hiQ !== null ? Math.abs(hiQ - currentHead) : Infinity; let r1, r2; if (qP.length === 0 || (qQ.length > 0 && x > y)) { r1 = runSSTFOnSubset(qQ, currentHead); r2 = runSSTFOnSubset(qP, r1.lastPosition); } else { r1 = runSSTFOnSubset(qP, currentHead); r2 = runSSTFOnSubset(qQ, r1.lastPosition); } totalMovement = r1.movementSubset + r2.movementSubset; fullPath = [...r1.pathSubset, ...r2.pathSubset.slice(1)]; servicedOrder = fullPath.slice(1).filter(pos => requestsCopy.includes(pos)); isServiceStop = [false, ...fullPath.slice(1).map(pos => requestsCopy.includes(pos))]; break; } default: console.error("Unknown algorithm:", algorithm); return { servicedOrder: [], totalMovement: 0, fullPath: [startHead], isServiceStop: [false] }; } if (fullPath.length === 0 && startHead !== undefined) { fullPath = [startHead]; isServiceStop = [false]; } if (fullPath.length !== isServiceStop.length) { console.warn(`Length mismatch ${algorithm}: P=${fullPath.length}, S=${isServiceStop.length}`); isServiceStop = [false, ...fullPath.slice(1).map(pos => requestsCopy.includes(pos))]; if (fullPath.length !== isServiceStop.length) { console.error(`Cannot fix length mismatch for ${algorithm}.`); return { servicedOrder: [], totalMovement: 0, fullPath: [startHead], isServiceStop: [false] }; } } return { servicedOrder, totalMovement, fullPath, isServiceStop }; }

        // --- Animation Control (Individual Traces) ---
        function animateMovement() { if (isAnimatingIndividual || isAnimatingAllInOne) return; if (currentRequests.length === 0 || selectedAlgorithms.length === 0) { showMessage("No requests or algorithms selected to animate."); return; } if (maxPathSteps <= 1 && currentRequests.length > 0) { showMessage("Error during calculation (maxPathSteps <= 1), cannot animate. Please Update & Reset.", true); return; } console.log("Starting individual trace animation..."); isAnimatingIndividual = true; disableUI(true); startButton.innerHTML = '<span class="lucide"></span> Animating Individuals...'; showMessage("Individual trace animation running..."); msPerUnitMovement = parseFloat(animationSpeedSelect.value) || 2; let currentAnimationPathStep = 0; const totalSegmentsToAnimate = maxPathSteps - 1; const timingAlgoName = selectedAlgorithms.includes(algorithmSelect.value) ? algorithmSelect.value : selectedAlgorithms[0]; const timingAlgoPath = allAlgorithmResults[timingAlgoName]?.fullPath || [initialHeadPosition]; let liveMoveCounters = {}; selectedAlgorithms.forEach(a => liveMoveCounters[a] = 0); requestAnimationFrame(() => { selectedAlgorithms.forEach(algoName => { if (traceCanvasContexts[algoName]) { const { canvas, ctx } = traceCanvasContexts[algoName]; liveMovementTrackers[algoName].textContent = ''; if (canvas.offsetWidth > 0 && canvas.offsetHeight > 0) { setupTraceCanvas(canvas, ctx, maxPathSteps, maxCylinder); drawInitialTracePoint(ctx, initialHeadPosition, maxPathSteps, maxCylinder, canvas.width, canvas.height); } } }); stepIndividualAnimation(); }); function stepIndividualAnimation() { if (currentAnimationPathStep >= totalSegmentsToAnimate || !isAnimatingIndividual) { console.log("Individual trace animation complete or stopped."); isAnimatingIndividual = false; if (!isAnimatingAllInOne) { disableUI(false); startButton.innerHTML = '<span class="lucide"></span> Animate Individual Traces'; } selectedAlgorithms.forEach(a => { if (liveMovementTrackers[a]) liveMovementTrackers[a].textContent = ''; }); if (currentAnimationPathStep >= totalSegmentsToAnimate) showMessage("Animation complete."); clearTimeout(animationTimeout); return; } const drawingStepIndex = currentAnimationPathStep + 1; let stepMovementForTiming = 0; if (drawingStepIndex < timingAlgoPath.length) { stepMovementForTiming = Math.abs(timingAlgoPath[drawingStepIndex] - timingAlgoPath[drawingStepIndex - 1]); } else { stepMovementForTiming = 1; } requestAnimationFrame(() => { if (!isAnimatingIndividual) return; selectedAlgorithms.forEach(algoName => { const result = allAlgorithmResults[algoName], path = result?.fullPath, isService = result?.isServiceStop, contextInfo = traceCanvasContexts[algoName], liveTracker = liveMovementTrackers[algoName]; if (path && isService && contextInfo && drawingStepIndex < path.length) { const currentTrack = path[drawingStepIndex], prevTrack = path[drawingStepIndex - 1], isEndPointService = isService[drawingStepIndex]; const { canvas, ctx } = contextInfo; if (canvas.width > 0 && canvas.height > 0) { drawTraceSegment(ctx, drawingStepIndex, prevTrack, currentTrack, maxPathSteps, maxCylinder, canvas.width, canvas.height, isEndPointService); liveMoveCounters[algoName] += Math.abs(currentTrack - prevTrack); if (liveTracker) liveTracker.textContent = `Live Move: ${liveMoveCounters[algoName]}`; } } }); currentAnimationPathStep++; let stepDuration = Math.max(MIN_STEP_DURATION, stepMovementForTiming * msPerUnitMovement); stepDuration = Math.min(stepDuration, MAX_STEP_DURATION); animationTimeout = setTimeout(stepIndividualAnimation, stepDuration); }); } }

        // --- Drawing Functions (All-in-One Setup/Axes/Map/Initial/Segment) ---
        function setupAllInOneCanvas(maxTotalPathSteps, maxCylValue) { const canvas = allInOneCanvas, ctx = allInOneCtx, currentWidth = canvas.offsetWidth, currentHeight = canvas.offsetHeight; if (currentWidth > 0 && currentHeight > 0) { canvas.width = currentWidth; canvas.height = currentHeight; ctx.fillStyle = AIO_BG_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height); drawAllInOneAxes(ctx, canvas.width, canvas.height, maxTotalPathSteps, maxCylValue); } else { console.warn("All-in-one canvas dimensions not available for setup."); } }
        function drawAllInOneAxes(ctx, width, height, maxSteps, maxCyl) { ctx.save(); ctx.strokeStyle = AIO_AXIS_COLOR; ctx.fillStyle = AIO_LABEL_COLOR; ctx.lineWidth = 1; ctx.font = '11px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const plotWidth = width - 2 * AIO_PADDING; const plotHeight = height - 2 * AIO_PADDING; ctx.beginPath(); ctx.moveTo(AIO_PADDING, AIO_PADDING); ctx.lineTo(width - AIO_PADDING, AIO_PADDING); ctx.stroke(); const numXTicks = Math.min(10, Math.floor(plotWidth / 60)); ctx.textBaseline = 'bottom'; for (let i = 0; i <= numXTicks; i++) { const cylinder = Math.round((i / numXTicks) * maxCyl); const x = mapToAllInOneCanvas(0, cylinder, maxSteps, maxCyl, width, height).x; const yPos = AIO_PADDING; ctx.beginPath(); ctx.moveTo(x, yPos); ctx.lineTo(x, yPos - 5); ctx.stroke(); ctx.fillText(cylinder, x, yPos - 8); } ctx.strokeStyle = AIO_GRID_COLOR; ctx.lineWidth = 0.5; ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; const yLabelInterval = Math.max(1, Math.ceil((maxSteps > 1 ? maxSteps - 1 : 1) / 10)); for (let i = 1; i < maxSteps; i++) { const y = mapToAllInOneCanvas(i, 0, maxSteps, maxCyl, width, height).y; ctx.beginPath(); ctx.moveTo(AIO_PADDING, y); ctx.lineTo(width - AIO_PADDING, y); ctx.stroke(); if (i > 0 && (i % yLabelInterval === 0 || i === maxSteps - 1)) { ctx.fillStyle = AIO_LABEL_COLOR; ctx.fillText(i, AIO_PADDING - 12, y); } } ctx.restore(); }
        function mapToAllInOneCanvas(stepIndex, cylinder, maxTotalPathSteps, maxCyl, canvasWidth, canvasHeight) { const plotWidth = canvasWidth - 2 * AIO_PADDING; const plotHeight = canvasHeight - 2 * AIO_PADDING; const x = AIO_PADDING + (cylinder / Math.max(1, maxCyl)) * plotWidth; const yFactor = (maxTotalPathSteps <= 1) ? 0 : stepIndex / (maxTotalPathSteps - 1); const y = AIO_PADDING + yFactor * plotHeight; return { x: Math.max(AIO_PADDING, Math.min(canvasWidth - AIO_PADDING, x)), y: Math.max(AIO_PADDING, Math.min(canvasHeight - AIO_PADDING, y)) }; }
        function drawAllInOneInitialPoint(cylinder, maxTotalPathSteps, maxCyl) { if (allInOneCanvas.width <= 0 || allInOneCanvas.height <= 0) return; const { x, y } = mapToAllInOneCanvas(0, cylinder, maxTotalPathSteps, maxCyl, allInOneCanvas.width, allInOneCanvas.height); const ctx = allInOneCtx; ctx.save(); ctx.fillStyle = AIO_START_POINT_COLOR; ctx.strokeStyle = AIO_AXIS_COLOR; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(x, y, AIO_POINT_RADIUS + 1, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = AIO_LABEL_COLOR; ctx.font = 'bold 10px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillText(`${cylinder}`, x, y - AIO_POINT_RADIUS - 4); ctx.restore(); }
        function drawAllInOneSegment(ctx, stepIndex, prevCylinder, currentCylinder, maxTotalPathSteps, maxCyl, width, height, baseColor, isServiceEndPoint) { if (width <= 0 || height <= 0 || stepIndex === 0) return; const startPoint = mapToAllInOneCanvas(stepIndex - 1, prevCylinder, maxTotalPathSteps, maxCyl, width, height); const endPoint = mapToAllInOneCanvas(stepIndex, currentCylinder, maxTotalPathSteps, maxCyl, width, height); const strokeColor = hexToRgba(baseColor, AIO_ALPHA); const fillColor = hexToRgba(baseColor, Math.min(1, AIO_ALPHA + 0.15)); ctx.save(); ctx.lineWidth = AIO_LINE_WIDTH; if (isServiceEndPoint) { ctx.setLineDash([]); ctx.strokeStyle = strokeColor; } else { ctx.setLineDash(DASH_PATTERN); ctx.strokeStyle = hexToRgba(baseColor, AIO_ALPHA * 0.8); } ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(endPoint.x, endPoint.y); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = fillColor; ctx.beginPath(); ctx.arc(endPoint.x, endPoint.y, AIO_POINT_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }

        // --- Animation Control (All-in-One - Improved Sync Logic) ---
        function animateAllInOne() { if (isAnimatingIndividual || isAnimatingAllInOne) return; if (currentRequests.length === 0 || selectedAlgorithms.length === 0) { showMessage("No requests or algorithms selected to animate."); return; } if (selectedAlgorithms.length < 2) { showMessage("Select at least two algorithms to animate combined plot."); return; } if (maxPathSteps <= 1 && currentRequests.length > 0) { showMessage("Error during calculation (maxPathSteps <= 1), cannot animate. Please Update & Reset.", true); return; } console.log("Starting combined animation (Improved Sync Logic)..."); isAnimatingAllInOne = true; disableUI(true); animateCombinedButton.innerHTML = '<span class="lucide"></span> Animating Combined...'; showMessage("Combined animation running..."); requestAnimationFrame(() => { if (allInOneCanvas.offsetWidth <= 0 || allInOneCanvas.offsetHeight <= 0) { console.error("All-in-one canvas not ready for animation."); showMessage("Error: Canvas not ready. Please try again.", true); isAnimatingAllInOne = false; disableUI(false); animateCombinedButton.innerHTML = '<span class="lucide"></span> Animate Combined Plot'; return; } setupAllInOneCanvas(maxPathSteps, maxCylinder); drawAllInOneInitialPoint(initialHeadPosition, maxPathSteps, maxCylinder); let animationStates = []; const selectedMovements = selectedAlgorithms.map(name => allAlgorithmResults[name]?.totalMovement ?? 0); const maxTotalMovement = Math.max(1, ...selectedMovements); selectedAlgorithms.forEach(algoName => { const result = allAlgorithmResults[algoName]; if (result && result.fullPath && result.isServiceStop) { const algoMovement = result.totalMovement; const speedFactor = Math.max(0.1, (maxTotalMovement + 1) / (algoMovement + 1)); const timePerUnit = AIO_BASE_TIME_SCALE / speedFactor; animationStates.push({ name: algoName, path: result.fullPath, isService: result.isServiceStop, color: ALGO_COLORS[algoName], currentStepIndex: 0, finished: result.fullPath.length <= 1, timeAccumulator: 0, timePerUnit: timePerUnit }); } }); let lastTimestamp = 0; function allInOneStepLoop(timestamp) { if (!isAnimatingAllInOne) { cancelAnimationFrame(allInOneAnimationId); return; } if (lastTimestamp === 0) lastTimestamp = timestamp; const deltaTime = timestamp - lastTimestamp; lastTimestamp = timestamp; let allDone = true; const segmentsToDrawThisFrame = []; animationStates.forEach(state => { if (state.finished || state.currentStepIndex >= state.path.length - 1) { state.finished = true; return; } allDone = false; state.timeAccumulator += deltaTime; const drawingStepIndex = state.currentStepIndex + 1; const targetPos = state.path[drawingStepIndex]; const prevPos = state.path[state.currentStepIndex]; const stepMove = Math.abs(targetPos - prevPos); const stepDurationNeeded = Math.max(MIN_STEP_DURATION * 0.5, stepMove * state.timePerUnit); if (state.timeAccumulator >= stepDurationNeeded) { segmentsToDrawThisFrame.push({ stateRef: state, drawingStepIndex: drawingStepIndex, prevPos: prevPos, targetPos: targetPos, stepDuration: stepDurationNeeded }); } }); segmentsToDrawThisFrame.forEach(segmentInfo => { const { stateRef, drawingStepIndex, prevPos, targetPos } = segmentInfo; const isEndPointService = stateRef.isService[drawingStepIndex]; drawAllInOneSegment(allInOneCtx, drawingStepIndex, prevPos, targetPos, maxPathSteps, maxCylinder, allInOneCanvas.width, allInOneCanvas.height, stateRef.color, isEndPointService); }); segmentsToDrawThisFrame.forEach(segmentInfo => { const { stateRef, stepDuration } = segmentInfo; stateRef.currentStepIndex++; stateRef.timeAccumulator = Math.max(0, stateRef.timeAccumulator - stepDuration); if (stateRef.currentStepIndex >= stateRef.path.length - 1) { stateRef.finished = true; } }); if (allDone) { console.log("Combined animation complete."); isAnimatingAllInOne = false; if (!isAnimatingIndividual) { disableUI(false); animateCombinedButton.innerHTML = '<span class="lucide"></span> Animate Combined Plot'; } showMessage("Combined animation complete."); cancelAnimationFrame(allInOneAnimationId); } else { allInOneAnimationId = requestAnimationFrame(allInOneStepLoop); } } allInOneAnimationId = requestAnimationFrame(allInOneStepLoop); }); }
        function getOrdinalSuffix(n) { const s = ["th", "st", "nd", "rd"], v = n % 100; return s[(v - 20) % 10] || s[v] || s[0]; }

        // --- Comparison Graph Drawing ---
        function drawComparisonGraph() { const canvas = comparisonCanvas, ctx = comparisonCtx, availableWidth = canvas.offsetWidth, availableHeight = canvas.offsetHeight; if (availableWidth <= 0 || availableHeight <= 0 || selectedAlgorithms.length === 0) { ctx.clearRect(0, 0, canvas.width, canvas.height); return; } canvas.width = availableWidth; canvas.height = availableHeight; ctx.clearRect(0, 0, canvas.width, canvas.height); let data = [], maxValue = 0; const metricCfg = METRIC_CONFIG[currentComparisonMetric]; const yAxisLabel = metricCfg.yAxisLabel; const valueFormatPrecision = metricCfg.precision; const lowerIsBetter = metricCfg.lowerIsBetter; selectedAlgorithms.forEach(algoName => { const result = allAlgorithmResults[algoName]; if (!result) return; let value, display; switch (currentComparisonMetric) { case 'movement': value = result.totalMovement; break; case 'avgSeek': value = result.avgSeekTime; break; case 'maxSeek': value = result.maxSeekTime; break; case 'stdDevSeek': value = result.stdDevSeekTime; break; case 'throughput': value = result.throughput; break; default: value = 0; } value = value ?? 0; if (currentComparisonMetric === 'throughput' && !isFinite(value)) { display = "Inf"; value = Infinity; } data.push({ label: algoName, value: value, display: display }); const numericVal = isFinite(value) ? value : 0; maxValue = Math.max(maxValue, numericVal); }); if (currentComparisonMetric === 'throughput' && maxValue === 0 && data.some(d => d.value === Infinity)) { maxValue = 1; } else if (maxValue === 0 && data.every(d => d.value === 0)) { maxValue = (currentComparisonMetric === 'throughput' ? 1 : 10); } let bestValue = lowerIsBetter ? Infinity : -Infinity; let bestAlgos = []; if (data.length > 0) { data.forEach(item => { const compareValue = item.value; if (lowerIsBetter) { if (compareValue < bestValue) { bestValue = compareValue; bestAlgos = [item.label]; } else if (compareValue === bestValue) { bestAlgos.push(item.label); } } else { if (compareValue > bestValue) { bestValue = compareValue; bestAlgos = [item.label]; } else if (compareValue === bestValue) { bestAlgos.push(item.label); } } }); } if (isComparisonSorted && data.length > 0) { data.sort((a, b) => a.value - b.value); data.forEach((item, index) => { item.rank = index + 1; }); } else { data.forEach(item => delete item.rank); } maxValue *= 1.1; const plotWidth = canvas.width - 2 * COMP_PADDING; const plotHeight = canvas.height - 2 * COMP_PADDING; const barTotalSpace = data.length > 0 ? plotWidth / data.length : plotWidth; const barSpacing = barTotalSpace * 0.2; const barWidth = barTotalSpace * 0.8; ctx.save(); ctx.strokeStyle = COMP_AXIS_COLOR; ctx.lineWidth = 1; ctx.font = '11px Inter, sans-serif'; ctx.beginPath(); ctx.moveTo(COMP_PADDING, COMP_PADDING); ctx.lineTo(COMP_PADDING, canvas.height - COMP_PADDING); ctx.stroke(); ctx.beginPath(); ctx.moveTo(COMP_PADDING, canvas.height - COMP_PADDING); ctx.lineTo(canvas.width - COMP_PADDING, canvas.height - COMP_PADDING); ctx.stroke(); const numYTicks = 5; ctx.fillStyle = COMP_LABEL_COLOR; ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; for (let i = 0; i <= numYTicks; i++) { const value = (maxValue / numYTicks) * i; const yValueRatio = maxValue === 0 ? 0 : (value / maxValue); const y = canvas.height - COMP_PADDING - yValueRatio * plotHeight; ctx.fillText(value.toFixed(valueFormatPrecision), COMP_PADDING - 10, y); ctx.strokeStyle = COMP_GRID_COLOR; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(COMP_PADDING + 1, y); ctx.lineTo(canvas.width - COMP_PADDING, y); ctx.stroke(); } ctx.save(); ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillStyle = COMP_LABEL_COLOR; ctx.font = '12px Inter, sans-serif'; ctx.translate(COMP_PADDING * 0.4, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.fillText(yAxisLabel, 0, 0); ctx.restore(); data.forEach((item, index) => { const x = COMP_PADDING + barSpacing / 2 + index * barTotalSpace; const numericValue = item.display === "Inf" ? 0 : item.value; const barHeightRatio = maxValue === 0 ? 0 : (numericValue / maxValue); const barHeight = Math.max(1, barHeightRatio * plotHeight); const y = canvas.height - COMP_PADDING - barHeight; ctx.fillStyle = bestAlgos.includes(item.label) ? COMP_BEST_BAR_COLOR : COMP_BAR_COLOR; ctx.fillRect(x, y, barWidth, barHeight); ctx.fillStyle = COMP_LABEL_COLOR; ctx.font = '11px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const barCenterX = x + barWidth / 2; ctx.fillText(item.label, barCenterX, canvas.height - COMP_PADDING + 6); ctx.fillStyle = bestAlgos.includes(item.label) ? COMP_BAR_VALUE_COLOR : COMP_BAR_VALUE_COLOR; if (bestAlgos.includes(item.label)) ctx.font = 'bold 10px Inter, sans-serif'; else ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; const displayValue = item.display ? item.display : item.value.toFixed(valueFormatPrecision); let labelText = displayValue; if (isComparisonSorted && item.rank !== null) { labelText += ` (${item.rank}${getOrdinalSuffix(item.rank)})`; } if (bestAlgos.includes(item.label)) { labelText = `🏆 ${labelText}`; } ctx.fillText(labelText, barCenterX, y - 4); }); ctx.restore(); }

        // --- Populate Comparison Table ---
        function populateComparisonTable() { comparisonTableBody.innerHTML = ''; const numMetrics = Object.keys(METRIC_CONFIG).length; if (selectedAlgorithms.length === 0) { const row = comparisonTableBody.insertRow(); const cell = row.insertCell(); cell.colSpan = numMetrics + 1; cell.textContent = "No algorithms selected."; cell.style.textAlign = 'center'; cell.style.padding = '1rem'; return; } let bestValue = METRIC_CONFIG[currentComparisonMetric].lowerIsBetter ? Infinity : -Infinity; let bestAlgos = []; selectedAlgorithms.forEach(algoName => { const result = allAlgorithmResults[algoName]; if (!result) return; let compareValue; switch (currentComparisonMetric) { case 'movement': compareValue = result.totalMovement; break; case 'avgSeek': compareValue = result.avgSeekTime; break; case 'maxSeek': compareValue = result.maxSeekTime; break; case 'stdDevSeek': compareValue = result.stdDevSeekTime; break; case 'throughput': compareValue = result.throughput; break; default: compareValue = Infinity; } if (METRIC_CONFIG[currentComparisonMetric].lowerIsBetter) { if (compareValue < bestValue) { bestValue = compareValue; bestAlgos = [algoName]; } else if (compareValue === bestValue) { bestAlgos.push(algoName); } } else { if (compareValue > bestValue) { bestValue = compareValue; bestAlgos = [algoName]; } else if (compareValue === bestValue) { bestAlgos.push(algoName); } } }); selectedAlgorithms.forEach(algoName => { const result = allAlgorithmResults[algoName]; if (!result) return; const row = comparisonTableBody.insertRow(); if (bestAlgos.includes(algoName)) { row.classList.add('best-algo-row'); } row.insertCell().textContent = algoName; row.insertCell().textContent = result.totalMovement.toFixed(METRIC_CONFIG.movement.precision); row.insertCell().textContent = result.avgSeekTime.toFixed(METRIC_CONFIG.avgSeek.precision); row.insertCell().textContent = result.maxSeekTime.toFixed(METRIC_CONFIG.maxSeek.precision); row.insertCell().textContent = result.stdDevSeekTime.toFixed(METRIC_CONFIG.stdDevSeek.precision); row.insertCell().textContent = isFinite(result.throughput) ? result.throughput.toFixed(METRIC_CONFIG.throughput.precision) : "Inf"; for (let i = 1; i < row.cells.length; i++) { row.cells[i].style.textAlign = 'right'; row.cells[i].style.fontFamily = "'Roboto Mono', monospace"; } }); }

        // --- Queue Scatter Plot Functions ---
        function setupQueuePlotCanvas() { const canvas = queuePlotCanvas; const ctx = queuePlotCtx; const currentWidth = canvas.offsetWidth; const currentHeight = canvas.offsetHeight; if (currentWidth > 0 && currentHeight > 0) { canvas.width = currentWidth; canvas.height = currentHeight; ctx.clearRect(0, 0, canvas.width, canvas.height); drawQueuePlotAxes(ctx, canvas.width, canvas.height, maxCylinder, currentRequests.length); } else { console.warn("Queue plot canvas dimensions not available for setup."); } }
        function drawQueuePlotAxes(ctx, width, height, maxCyl, numRequests) { ctx.save(); ctx.strokeStyle = QPLOT_AXIS_COLOR; ctx.fillStyle = QPLOT_LABEL_COLOR; ctx.lineWidth = 1; ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const plotHeight = height - 2 * QPLOT_PADDING; const plotWidth = width - 2 * QPLOT_PADDING; ctx.beginPath(); ctx.moveTo(QPLOT_PADDING, QPLOT_PADDING); ctx.lineTo(QPLOT_PADDING, height - QPLOT_PADDING); ctx.stroke(); ctx.beginPath(); ctx.moveTo(QPLOT_PADDING, height - QPLOT_PADDING); ctx.lineTo(width - QPLOT_PADDING, height - QPLOT_PADDING); ctx.stroke(); const numYTicks = Math.min(10, Math.floor(plotHeight / 30)); ctx.textAlign = 'right'; for (let i = 0; i <= numYTicks; i++) { const requestIndex = Math.round((i / numYTicks) * Math.max(0, numRequests - 1)); const yRatio = numRequests <= 1 ? 0 : requestIndex / (numRequests - 1); const y = QPLOT_PADDING + yRatio * plotHeight; ctx.fillText(requestIndex, QPLOT_PADDING - 8, y); ctx.strokeStyle = QPLOT_GRID_COLOR; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(QPLOT_PADDING + 1, y); ctx.lineTo(width - QPLOT_PADDING, y); ctx.stroke(); } const numXTicks = Math.min(10, Math.floor(plotWidth / 50)); ctx.textAlign = 'center'; ctx.textBaseline = 'top'; for (let i = 0; i <= numXTicks; i++) { const cylinder = Math.round((i / numXTicks) * maxCyl); const xRatio = maxCyl === 0 ? 0 : cylinder / maxCyl; const x = QPLOT_PADDING + xRatio * plotWidth; ctx.strokeStyle = QPLOT_AXIS_COLOR; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(x, height - QPLOT_PADDING); ctx.lineTo(x, height - QPLOT_PADDING + 5); ctx.stroke(); ctx.fillStyle = QPLOT_LABEL_COLOR; ctx.fillText(cylinder, x, height - QPLOT_PADDING + 8); ctx.strokeStyle = QPLOT_GRID_COLOR; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(x, QPLOT_PADDING); ctx.lineTo(x, height - QPLOT_PADDING - 1); ctx.stroke(); } ctx.restore(); }
        function mapToQueuePlotCanvas(requestIndex, cylinder, maxCyl, numRequests, canvasWidth, canvasHeight) { const plotWidth = canvasWidth - 2 * QPLOT_PADDING; const plotHeight = canvasHeight - 2 * QPLOT_PADDING; const x = QPLOT_PADDING + (cylinder / Math.max(1, maxCyl)) * plotWidth; const yFactor = (numRequests <= 1) ? 0 : requestIndex / (numRequests - 1); const y = QPLOT_PADDING + yFactor * plotHeight; return { x: Math.max(QPLOT_PADDING, Math.min(canvasWidth - QPLOT_PADDING, x)), y: Math.max(QPLOT_PADDING, Math.min(canvasHeight - QPLOT_PADDING, y)) }; }
        function drawQueuePlotPoints() { const canvas = queuePlotCanvas; const ctx = queuePlotCtx; if (canvas.width <= 0 || canvas.height <= 0 || currentRequests.length === 0) { ctx.clearRect(0, 0, canvas.width, canvas.height); drawQueuePlotAxes(ctx, canvas.width, canvas.height, maxCylinder, 0); return; } ctx.save(); ctx.fillStyle = QPLOT_POINT_COLOR; const numReq = currentRequests.length; currentRequests.forEach((cylinder, index) => { const { x, y } = mapToQueuePlotCanvas(index, cylinder, maxCylinder, numReq, canvas.width, canvas.height); ctx.beginPath(); ctx.arc(x, y, QPLOT_POINT_RADIUS, 0, Math.PI * 2); ctx.fill(); }); ctx.restore(); }

        // --- Utility Functions ---
        function showMessage(msg, isError = false) { messageBox.textContent = msg; messageBox.style.color = isError ? '#dc2626' : '#4f46e5'; }
        function hexToRgba(hex, alpha = 1) { hex = hex.replace('#', ''); let r, g, b; if (hex.length === 3) { r = parseInt(hex.substring(0, 1).repeat(2), 16); g = parseInt(hex.substring(1, 2).repeat(2), 16); b = parseInt(hex.substring(2, 3).repeat(2), 16); } else if (hex.length === 6) { r = parseInt(hex.substring(0, 2), 16); g = parseInt(hex.substring(2, 4), 16); b = parseInt(hex.substring(4, 6), 16); } else { console.warn("Invalid hex color:", hex); return `rgba(100, 100, 100, ${alpha})`; } alpha = Math.max(0, Math.min(1, alpha)); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
        function updateSortButtonState() { if (isComparisonSorted) { sortComparisonBtn.innerHTML = '<span class="lucide"></span> Show Default Order'; sortComparisonBtn.classList.add('active'); } else { sortComparisonBtn.innerHTML = '<span class="lucide"></span> Sort Ascending'; sortComparisonBtn.classList.remove('active'); } }

        // --- Algorithm Selection Checkbox Handling ---
        function setupAlgorithmCheckboxes() { algoSelectionGrid.innerHTML = ''; ALL_ALGORITHMS.forEach(algoName => { const label = document.createElement('label'); label.className = 'algo-checkbox-label'; label.htmlFor = `algo-checkbox-${algoName}`; const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = `algo-checkbox-${algoName}`; checkbox.value = algoName; checkbox.checked = selectedAlgorithms.includes(algoName); checkbox.addEventListener('change', handleAlgorithmSelectionChange); label.appendChild(checkbox); label.appendChild(document.createTextNode(algoName)); algoSelectionGrid.appendChild(label); }); }
        function updateAlgorithmCheckboxes() { ALL_ALGORITHMS.forEach(algoName => { const checkbox = getEl(`algo-checkbox-${algoName}`); if (checkbox) checkbox.checked = selectedAlgorithms.includes(algoName); }); }
        function handleAlgorithmSelectionChange() { if (!isAnimatingIndividual && !isAnimatingAllInOne) { initializeSimulation(false); } else { showMessage("Cannot change selection during animation.", true); this.checked = !this.checked; } }

        // --- Handle Queue Generation Button Click ---
        function handleGenerateQueue(triggerInit = true) {
            if (isAnimatingIndividual || isAnimatingAllInOne) {
                showMessage("Cannot generate queue during animation.", true);
                return;
            }
            const type = generateTypeSelect.value;
            const numReq = parseInt(generateNumRequestsInput.value, 10);
            const maxCyl = parseInt(maxCylinderInput.value, 10);
            const numClusters = parseInt(generateNumClustersInput.value, 10);

            // Input Validation
            let validationError = false;
            if (isNaN(numReq) || numReq < 1) { showMessage("Invalid Number of Requests for generation.", true); validationError = true; }
            if (isNaN(maxCyl) || maxCyl < 0) { showMessage("Invalid Max Cylinder value for generation.", true); validationError = true; }
            if (type === 'clustered' && (isNaN(numClusters) || numClusters < 1)) { showMessage("Invalid Number of Clusters for generation.", true); validationError = true; }
            if (validationError) return;

            let generatedQueue = [];
            try {
                switch (type) {
                    case 'uniform': generatedQueue = generateUniformRandomJS(maxCyl, numReq); break;
                    case 'sequential': generatedQueue = generateSequentialJS(maxCyl, numReq); break;
                    case 'clustered': generatedQueue = generateClusteredJS(maxCyl, numReq, numClusters); break;
                    case 'mixed': generatedQueue = generateMixedJS(maxCyl, numReq); break;
                    default: showMessage("Unknown generation type selected.", true); return;
                }
                generatedQueueString = generatedQueue.join(', ');
                requestQueueInput.value = generatedQueueString;
                showMessage(`Generated ${generatedQueue.length} requests of type '${type}'. Click 'Update Simulation'.`, false);
                if (triggerInit) {
                    // Allow message to show briefly
                    setTimeout(() => initializeSimulation(false, true), 50);
                }
            } catch (error) {
                console.error("Error generating queue:", error);
                showMessage("An error occurred during queue generation. Check console.", true);
                generatedQueueString = ""; requestQueueInput.value = ""; // Clear potentially bad data
            }
        }

        // --- Event Listeners ---
        algorithmSelect.addEventListener('change', (e) => { if (!isAnimatingIndividual && !isAnimatingAllInOne) updateDetailsDisplay(e.target.value); });
        startHeadInput.addEventListener('change', () => { if (!isAnimatingIndividual && !isAnimatingAllInOne) initializeSimulation(false); });
        maxCylinderInput.addEventListener('change', () => { if (!isAnimatingIndividual && !isAnimatingAllInOne) initializeSimulation(false); });
        updateQueueButton.addEventListener('click', () => { if (!isAnimatingIndividual && !isAnimatingAllInOne) initializeSimulation(false); });
        requestQueueInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); if (!isAnimatingIndividual && !isAnimatingAllInOne && currentQueueMode === 'manual') initializeSimulation(false); } });
        startButton.addEventListener('click', animateMovement);
        animateCombinedButton.addEventListener('click', animateAllInOne);
        resetButton.addEventListener('click', () => { clearTimeout(animationTimeout); cancelAnimationFrame(allInOneAnimationId); isAnimatingIndividual = false; isAnimatingAllInOne = false; initializeSimulation(true); disableUI(currentRequests.length === 0); showMessage("Simulation reset to default values."); });
        animationSpeedSelect.addEventListener('change', () => { msPerUnitMovement = parseFloat(animationSpeedSelect.value) || 2; });
        function setActiveMetricButton(activeBtnId) { metricButtons.forEach(btn => { btn.classList.toggle('active', btn.id === activeBtnId); }); }
        metricButtons.forEach(button => { const metricKey = button.id.replace('compare-', '').replace('-btn', ''); button.addEventListener('click', () => { if (currentComparisonMetric !== metricKey && !isAnimatingIndividual && !isAnimatingAllInOne) { currentComparisonMetric = metricKey; isComparisonSorted = false; updateSortButtonState(); setActiveMetricButton(button.id); drawComparisonGraph(); populateComparisonTable(); } }); });
        sortComparisonBtn.addEventListener('click', () => { if (!isAnimatingIndividual && !isAnimatingAllInOne) { isComparisonSorted = !isComparisonSorted; updateSortButtonState(); drawComparisonGraph(); } });
        queueModeManualRadio.addEventListener('change', toggleQueueInputMode); queueModeGenerateRadio.addEventListener('change', toggleQueueInputMode);
        generateTypeSelect.addEventListener('change', toggleClusterOptions);
        generateQueueButton.addEventListener('click', () => handleGenerateQueue(true));

        let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { console.log("Window resized..."); if (!isAnimatingIndividual && !isAnimatingAllInOne) { console.log("Re-drawing layout..."); maxPathSteps = 0; selectedAlgorithms.forEach(name => { if (allAlgorithmResults[name]) maxPathSteps = Math.max(maxPathSteps, allAlgorithmResults[name].fullPath.length); }); maxPathSteps = Math.max(1, maxPathSteps); setupQueuePlotCanvas(); drawQueuePlotPoints(); /* Redraw queue plot first*/ selectedAlgorithms.forEach(algoName => { if (traceCanvasContexts[algoName]) { const { canvas, ctx } = traceCanvasContexts[algoName]; setupTraceCanvas(canvas, ctx, maxPathSteps, maxCylinder); const result = allAlgorithmResults[algoName]; if (result && result.fullPath.length > 0) { drawInitialTracePoint(ctx, result.fullPath[0], maxPathSteps, maxCylinder, canvas.width, canvas.height); for (let i = 1; i < result.fullPath.length; i++) { drawTraceSegment(ctx, i, result.fullPath[i - 1], result.fullPath[i], maxPathSteps, maxCylinder, canvas.width, canvas.height, result.isServiceStop[i]); } } } }); if (selectedAlgorithms.length > 0 && allInOneCanvas.offsetWidth > 0 && allInOneCanvas.offsetHeight > 0) { setupAllInOneCanvas(maxPathSteps, maxCylinder); drawAllInOneInitialPoint(initialHeadPosition, maxPathSteps, maxCylinder); selectedAlgorithms.forEach(algoName => { const state = allAlgorithmResults[algoName]; if (state && state.fullPath && state.fullPath.length > 1) { for (let i = 1; i < state.fullPath.length; ++i) { drawAllInOneSegment(allInOneCtx, i, state.fullPath[i - 1], state.fullPath[i], maxPathSteps, maxCylinder, allInOneCanvas.width, allInOneCanvas.height, ALGO_COLORS[algoName], state.isServiceStop[i]); } } }); } drawComparisonGraph(); } else { console.log("Resize ignored during animation."); showMessage("Please wait for animation to finish before resizing.", true); } }, 250); });
        document.addEventListener('DOMContentLoaded', () => { setupAlgorithmCheckboxes(); toggleQueueInputMode(); toggleClusterOptions(); initializeSimulation(true); });
    </script>

</body>

</html>
